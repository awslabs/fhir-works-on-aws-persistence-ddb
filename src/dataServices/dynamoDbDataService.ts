/*
 *  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *  SPDX-License-Identifier: Apache-2.0
 */

/* eslint-disable class-methods-use-this */

import uuidv4 from 'uuid/v4';
import {
    BatchReadWriteRequest,
    BulkDataAccess,
    BundleResponse,
    clone,
    ConditionalDeleteResourceRequest,
    CreateResourceRequest,
    DeleteResourceRequest,
    ExportJobStatus,
    generateMeta,
    GenericResponse,
    GetExportStatusResponse,
    InitiateExportRequest,
    PatchResourceRequest,
    Persistence,
    ReadResourceRequest,
    ResourceNotFoundError,
    ResourceVersionNotFoundError,
    TooManyConcurrentExportRequestsError,
    UpdateResourceRequest,
    vReadResourceRequest,
} from 'fhir-works-on-aws-interface';
import DynamoDB, { ItemList } from 'aws-sdk/clients/dynamodb';
import { DynamoDBConverter } from './dynamoDb';
import DOCUMENT_STATUS from './documentStatus';
import { DynamoDbBundleService } from './dynamoDbBundleService';
import { DynamoDbUtil } from './dynamoDbUtil';
import DynamoDbParamBuilder from './dynamoDbParamBuilder';
import DynamoDbHelper from './dynamoDbHelper';
import { getBulkExportResults, startJobExecution } from '../bulkExport/bulkExport';
import { BulkExportJob } from '../bulkExport/types';

const buildExportJob = (initiateExportRequest: InitiateExportRequest): BulkExportJob => {
    const initialStatus: ExportJobStatus = 'in-progress';
    return {
        jobId: uuidv4(),
        jobOwnerId: initiateExportRequest.requesterUserId,
        exportType: initiateExportRequest.exportType,
        groupId: initiateExportRequest.groupId ?? '',
        outputFormat: initiateExportRequest.outputFormat ?? 'ndjson',
        since: initiateExportRequest.since ?? '1800-01-01T00:00:00.000Z', // Default to a long time ago in the past
        type: initiateExportRequest.type ?? '',
        transactionTime: initiateExportRequest.transactionTime,
        jobStatus: initialStatus,
        jobFailedMessage: '',
    };
};

export class DynamoDbDataService implements Persistence, BulkDataAccess {
    private readonly MAXIMUM_SYSTEM_LEVEL_CONCURRENT_REQUESTS = 2;

    private readonly MAXIMUM_CONCURRENT_REQUEST_PER_USER = 1;

    updateCreateSupported: boolean = false;

    private readonly transactionService: DynamoDbBundleService;

    private readonly dynamoDbHelper: DynamoDbHelper;

    private readonly dynamoDb: DynamoDB;

    constructor(dynamoDb: DynamoDB) {
        this.dynamoDbHelper = new DynamoDbHelper(dynamoDb);
        this.transactionService = new DynamoDbBundleService(dynamoDb);
        this.dynamoDb = dynamoDb;
    }

    async readResource(request: ReadResourceRequest): Promise<GenericResponse> {
        return this.dynamoDbHelper.getMostRecentUserReadableResource(request.resourceType, request.id);
    }

    async vReadResource(request: vReadResourceRequest): Promise<GenericResponse> {
        const { resourceType, id, vid } = request;
        const params = DynamoDbParamBuilder.buildGetItemParam(id, parseInt(vid, 10));
        const result = await this.dynamoDb.getItem(params).promise();
        if (result.Item === undefined) {
            throw new ResourceVersionNotFoundError(resourceType, id, vid);
        }
        let item = DynamoDBConverter.unmarshall(result.Item);
        if (item.resourceType !== resourceType) {
            throw new ResourceVersionNotFoundError(resourceType, id, vid);
        }
        item = DynamoDbUtil.cleanItem(item);
        return {
            message: 'Resource found',
            resource: item,
        };
    }

    async createResource(request: CreateResourceRequest) {
        const { resourceType, resource } = request;

        const vid = 1;
        let item = resource;
        item.resourceType = resourceType;
        item.meta = generateMeta(vid.toString());

        const params = DynamoDbParamBuilder.buildPutAvailableItemParam(item, uuidv4(), vid);
        try {
            await this.dynamoDb.putItem(params).promise();
        } catch (e) {
            if (e.code === 'ConditionalCheckFailedException') {
                // It is highly unlikely that the autogenerated id will collide with a preexisting id, but adding this for additional debugging context
                throw new Error('Auto generated id matched an existing id');
            }
            throw e;
        }
        const newItem = DynamoDBConverter.unmarshall(params.Item);
        item = DynamoDbUtil.cleanItem(newItem);
        return {
            success: true,
            message: 'Resource created',
            resource: item,
        };
    }

    async deleteResource(request: DeleteResourceRequest) {
        const { resourceType, id } = request;
        const itemServiceResponse = await this.readResource({ resourceType, id });

        const { versionId } = itemServiceResponse.resource.meta;

        return this.deleteVersionedResource(resourceType, id, parseInt(versionId, 10));
    }

    async deleteVersionedResource(resourceType: string, id: string, vid: number) {
        const updateStatusToDeletedParam = DynamoDbParamBuilder.buildUpdateDocumentStatusParam(
            DOCUMENT_STATUS.AVAILABLE,
            DOCUMENT_STATUS.DELETED,
            id,
            vid,
            resourceType,
        ).Update;
        await this.dynamoDb.updateItem(updateStatusToDeletedParam).promise();
        return {
            success: true,
            message: `Successfully deleted ResourceType: ${resourceType}, Id: ${id}, VersionId: ${vid}`,
        };
    }

    async updateResource(request: UpdateResourceRequest) {
        const { resource, resourceType, id } = request;
        const resourceCopy = { ...resource };

        // Will throw ResourceNotFoundError if resource can't be found
        await this.readResource({ resourceType, id });

        const batchRequest: BatchReadWriteRequest = {
            operation: 'update',
            resourceType,
            id,
            resource: resourceCopy,
        };

        // Sending the request to `atomicallyReadWriteResources` to take advantage of LOCKING management handled by
        // that method
        const response: BundleResponse = await this.transactionService.transaction({
            requests: [batchRequest],
            startTime: new Date(),
        });
        const item = clone(resource);
        const batchReadWriteEntryResponse = response.batchReadWriteResponses[0];
        item.meta = generateMeta(batchReadWriteEntryResponse.vid, new Date(batchReadWriteEntryResponse.lastModified));
        return {
            success: true,
            message: 'Resource updated',
            resource: item,
        };
    }

    async initiateExport(initiateExportRequest: InitiateExportRequest): Promise<string> {
        await this.throttleExportRequestsIfNeeded(initiateExportRequest.requesterUserId);
        // Create new export job
        const exportJob: BulkExportJob = buildExportJob(initiateExportRequest);

        await startJobExecution(exportJob);

        const params = DynamoDbParamBuilder.buildPutCreateExportRequest(exportJob);
        await this.dynamoDb.putItem(params).promise();
        return exportJob.jobId;
    }

    async throttleExportRequestsIfNeeded(requesterUserId: string) {
        const jobStatusesToThrottle: ExportJobStatus[] = ['canceling', 'in-progress'];
        const exportJobItems = await this.getJobsWithExportStatuses(jobStatusesToThrottle);

        if (exportJobItems) {
            const numberOfConcurrentUserRequest = exportJobItems.filter(item => {
                return DynamoDBConverter.unmarshall(item).jobOwnerId === requesterUserId;
            }).length;
            if (
                numberOfConcurrentUserRequest >= this.MAXIMUM_CONCURRENT_REQUEST_PER_USER ||
                exportJobItems.length >= this.MAXIMUM_SYSTEM_LEVEL_CONCURRENT_REQUESTS
            ) {
                throw new TooManyConcurrentExportRequestsError();
            }
        }
    }

    async getJobsWithExportStatuses(jobStatuses: ExportJobStatus[]): Promise<ItemList> {
        const jobStatusPromises = jobStatuses.map((jobStatus: ExportJobStatus) => {
            const projectionExpression = 'jobOwnerId, jobStatus';
            const queryJobStatusParam = DynamoDbParamBuilder.buildQueryExportRequestJobStatus(
                jobStatus,
                projectionExpression,
            );
            return this.dynamoDb.query(queryJobStatusParam).promise();
        });

        const jobStatusResponses = await Promise.all(jobStatusPromises);
        let allJobStatusItems: ItemList = [];
        jobStatusResponses.forEach((jobStatusResponse: DynamoDB.QueryOutput) => {
            if (jobStatusResponse.Items) {
                allJobStatusItems = allJobStatusItems.concat(jobStatusResponse.Items);
            }
        });
        return allJobStatusItems;
    }

    async cancelExport(jobId: string): Promise<void> {
        const jobDetailsParam = DynamoDbParamBuilder.buildGetExportRequestJob(jobId);
        const jobDetailsResponse = await this.dynamoDb.getItem(jobDetailsParam).promise();
        if (!jobDetailsResponse.Item) {
            throw new ResourceNotFoundError('$export', jobId);
        }
        const jobItem = DynamoDBConverter.unmarshall(jobDetailsResponse.Item);
        if (['completed', 'failed'].includes(jobItem.jobStatus)) {
            throw new Error(`Job cannot be canceled because job is already in ${jobItem.jobStatus} state`);
        }
        // A job in the canceled or canceling state doesn't need to be updated to 'canceling'
        if (['canceled', 'canceling'].includes(jobItem.jobStatus)) {
            return;
        }

        const params = DynamoDbParamBuilder.buildUpdateExportRequestJobStatus(jobId, 'canceling');
        await this.dynamoDb.updateItem(params).promise();
    }

    async getExportStatus(jobId: string): Promise<GetExportStatusResponse> {
        const jobDetailsParam = DynamoDbParamBuilder.buildGetExportRequestJob(jobId);
        const jobDetailsResponse = await this.dynamoDb.getItem(jobDetailsParam).promise();
        if (!jobDetailsResponse.Item) {
            throw new ResourceNotFoundError('$export', jobId);
        }

        const item = DynamoDBConverter.unmarshall(<DynamoDB.AttributeMap>jobDetailsResponse.Item);

        const {
            jobStatus,
            jobOwnerId,
            transactionTime,
            exportType,
            outputFormat,
            since,
            type,
            groupId,
            errorArray = [],
            errorMessage = '',
        } = item;

        const exportedFileUrls = jobStatus === 'completed' ? await getBulkExportResults(jobId) : [];

        const getExportStatusResponse: GetExportStatusResponse = {
            jobOwnerId,
            jobStatus,
            exportedFileUrls,
            transactionTime,
            exportType,
            outputFormat,
            since,
            type,
            groupId,
            errorArray,
            errorMessage,
        };

        return getExportStatusResponse;
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalCreateResource(request: CreateResourceRequest, queryParams: any): Promise<GenericResponse> {
        throw new Error('Method not implemented.');
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalUpdateResource(request: UpdateResourceRequest, queryParams: any): Promise<GenericResponse> {
        throw new Error('Method not implemented.');
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    patchResource(request: PatchResourceRequest): Promise<GenericResponse> {
        throw new Error('Method not implemented.');
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalPatchResource(request: PatchResourceRequest, queryParams: any): Promise<GenericResponse> {
        throw new Error('Method not implemented.');
    }

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    conditionalDeleteResource(request: ConditionalDeleteResourceRequest, queryParams: any): Promise<GenericResponse> {
        throw new Error('Method not implemented.');
    }
}
